#!/bin/zsh

echo "🔄 Updating 'last_modified_at' for staged Markdown/HTML..."

# Nur staged Dateien, die hinzugefügt/geändert sind
staged_files=($(git diff --cached --name-only --diff-filter=ACMRT | grep -E '\.(md|markdown|html)$' || true))
if [[ ${#staged_files[@]} -eq 0 ]]; then
  echo "ℹ️  No staged Markdown/HTML files."
  exit 0
fi

# Commit-Datum: bevorzugt GIT_AUTHOR_DATE, sonst heutiges Datum (YYYY-MM-DD)
commit_date="${GIT_AUTHOR_DATE:-$(date +%F)}"
# Falls GIT_AUTHOR_DATE im Format "YYYY-MM-DD HH:MM:SS ±TZ" kommt → nur Datum extrahieren
commit_date="${commit_date%% *}"

for file in "${staged_files[@]}"; do
  [[ -f "$file" ]] || continue

  # Front Matter vorhanden? (erste Zeile '---')
  if ! head -n 1 "$file" | grep -q "^---"; then
    # Ohne Front Matter: nichts tun (oder hier optional eines erzeugen)
    continue
  fi

  # Fall A: Feld existiert bereits → ersetzen (auch wenn leer)
  if grep -q "^last_modified_at:" "$file"; then
    # Ersetze komplette Zeile; BSD sed braucht leeres Backup-Suffix
    sed -i '' -E "s/^last_modified_at:[[:space:]].*$/last_modified_at: ${commit_date}/" "$file"
  else
    # Fall B: Feld fehlt → direkt nach der ersten '---' Zeile einfügen
    awk -v date="$commit_date" '
      NR==1 { print; print "last_modified_at: " date; next }
      { print }
    ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
  fi

  # Datei erneut stagen (Inhalt geändert)
  git add "$file"
  echo "✅ ${file} → last_modified_at: ${commit_date}"
done

echo "✨ Done."