#!/bin/zsh

echo "ðŸ”„ Updating 'last_modified_at' for staged content..."

# Nur Dateien, die gerade committet werden (staged), und nur bestimmte Endungen
staged_files=($(git diff --cached --name-only --diff-filter=ACMRT | grep -E '\.(md|markdown|html)$' || true))

if [[ ${#staged_files[@]} -eq 0 ]]; then
  echo "â„¹ï¸  No staged Markdown/HTML files."
  exit 0
fi

# Heutiges Datum als Fallback (fÃ¼r neue Dateien ohne Git-Historie)
today=$(date +%F)

for file in "${staged_files[@]}"; do
  # Datei muss existieren (kann z. B. gelÃ¶scht sein)
  [[ -f "$file" ]] || continue

  # Front Matter prÃ¼fen: beginnt Datei mit '---'?
  head -n 1 "$file" | grep -q "^---" || continue

  # Letztes Ã„nderungsdatum aus Git, Fallback auf heute
  last_modified=$(git log -1 --format="%cs" -- "$file" 2>/dev/null)
  [[ -z "$last_modified" ]] && last_modified="$today"

  # Fall A: last_modified_at existiert bereits (auch wenn leer) â†’ Zeile ersetzen
  if grep -q "^last_modified_at:" "$file"; then
    # BSD sed (macOS): Backup-Endung erforderlich
    sed -i '' -E "s/^last_modified_at:.*$/last_modified_at: ${last_modified}/" "$file"
  else
    # Fall B: Feld fehlt â†’ gleich NACH der ersten '---' Zeile einfÃ¼gen
    awk -v date="$last_modified" 'NR==1{print; getline; print "last_modified_at: " date; print; next}1' "$file" > "$file.tmp" \
      && mv "$file.tmp" "$file"
  fi

  # Datei erneut fÃ¼r Commit vormerken (falls Inhalt geÃ¤ndert)
  git add "$file"
  echo "âœ… ${file} â†’ last_modified_at: ${last_modified}"
done

echo "âœ¨ Done."