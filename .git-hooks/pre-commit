#!/bin/zsh

echo "ðŸ”„ Updating 'last_modified_at' for staged Markdown/HTML..."

# Nur staged Dateien, die hinzugefÃ¼gt/geÃ¤ndert sind
staged_files=($(git diff --cached --name-only --diff-filter=ACMRT | grep -E '\.(md|markdown|html)$' || true))
if [[ ${#staged_files[@]} -eq 0 ]]; then
  echo "â„¹ï¸  No staged Markdown/HTML files."
  exit 0
fi

# Commit-Datum: bevorzugt GIT_AUTHOR_DATE, sonst heutiges Datum (YYYY-MM-DD)
commit_date="${GIT_AUTHOR_DATE:-$(date +%F)}"
# Falls GIT_AUTHOR_DATE im Format "YYYY-MM-DD HH:MM:SS Â±TZ" kommt â†’ nur Datum extrahieren
commit_date="${commit_date%% *}"

for file in "${staged_files[@]}"; do
  [[ -f "$file" ]] || continue

  # Front Matter vorhanden? (erste Zeile '---')
  if ! head -n 1 "$file" | grep -q "^---"; then
    # Ohne Front Matter: nichts tun (oder hier optional eines erzeugen)
    continue
  fi

  # Fall A: Feld existiert bereits â†’ ersetzen (auch wenn leer)
  if grep -q "^last_modified_at:" "$file"; then
    # Ersetze komplette Zeile; BSD sed braucht leeres Backup-Suffix
    sed -i '' -E "s/^last_modified_at:[[:space:]].*$/last_modified_at: ${commit_date}/" "$file"
  else
    # Fall B: Feld fehlt â†’ direkt nach der ersten '---' Zeile einfÃ¼gen
    awk -v date="$commit_date" '
      NR==1 { print; print "last_modified_at: " date; next }
      { print }
    ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
  fi

  # Datei erneut stagen (Inhalt geÃ¤ndert)
  git add "$file"
  echo "âœ… ${file} â†’ last_modified_at: ${commit_date}"
done

echo "âœ¨ Done."